// The extractor is used for extracting data from the API like endpoints
// (with methods and paths). After the extraction is done it outputs the data
// to the console and also generates Dart, TypeScript files for usage and a
// small HTML for documentation purposes.
package main

import (
	"bytes"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	mrand "math/rand"
	"net/http"
	"net/http/httptest"
	"os"
	"reflect"
	"runtime"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
	"gitlab.com/vlad.anghel/schedder-api"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// GeneratedFileWarning is a warning for other people to not edit the generated
// files
const GeneratedFileWarning = "GENERATED FILE! DO NOT EDIT, YOUR CHANGES MAY " +
	"BE OVERWRITTEN"

// GeneratedByMessage is a simple message that signals the file was generated
// using this extractor
const GeneratedByMessage = "Generated by schedder-api/cmd/extractor"

// Middleware represents a middleware used in the API.
type Middleware struct {
	Name      string
	TypeParam string
}

// HTMLRequirement generates a requirement text to be used in the HTML
// generator.
func (m *Middleware) HTMLRequirement() string {
	switch m.Name {
	case "WithJSON[...]":
		return "Requires JSON input"
	case "AuthenticatedEndpoint-fm":
		return "Required Header: <code>Authentication: Bearer $TOKEN</code>"
	case "WithSessionID-fm":
		return "Required URL parameter: <code>sessionID</code>"
	case "WithAccountID-fm":
		return "Required URL parameter: <code>accountID</code>"
	case "WithTenantID-fm":
		return "Required URL parameter: <code>tenantID</code>"
	case "AdminEndpoint-fm":
		return "Requires the authenticated user to be an <strong>Admin</strong>"
	case "TenantManagerEndpoint-fm":
		return "Requires the authenticated user to be an <strong>Manager</strong> of <strong>tenantID</strong> from the URL parameter"
	default:
		panic("I don't know how to make this into a requirement:" + m.Name)
	}
}

// Endpoint represents an endpoint in the API.
type Endpoint struct {
	// The method for this endpoint, i.e. GET
	Method string
	// The path for this endpoint, i.e. /accounts
	Path string
	// The name of this endpoint, set to the name of the handler
	Name string

	// Input json object description
	Input *Object
	// Output json object description
	Output *Object
	// The middlewares used by this endpoint
	Middlewares []Middleware
}

// InputString returns the name of the Input object or empty string if no input
// is required.
func (e Endpoint) InputString() string {
	if e.Input == nil {
		return ""
	}

	return e.Input.Name
}

// OutputString returns the name of the Output object or empty string if no
// output is required.
func (e Endpoint) OutputString() string {
	if e.Output == nil {
		return ""
	}

	return e.Output.Name
}

// CurlExample generate an example usage of the endpoint using 'curl'.
func (e Endpoint) CurlExample() string {
	b := strings.Builder{}
	b.WriteString("curl -X ")
	b.WriteString(e.Method)
	b.WriteRune('\n')
	if e.Input != nil {
		b.WriteString(" --data '")
		b.WriteString(e.Input.Sample(0))
		b.WriteString("'\n")
	}
	b.WriteString(" localhost:2023")
	b.WriteString(e.Path)

	return b.String()
}

// DartMethod converts an endpoint name to a Dart-style method name.
func (e Endpoint) DartMethod() string {
	return strings.ToLower(e.Method)
}

// Field represents a field in a JSON request/response
type Field struct {
	// Name of the field
	Name string
	// TypeName is the type of that field
	TypeName string
	// OmitEmpty represents if the type is nullable
	OmitEmpty bool
}

// Quote the string
func Quote(s string) string {
	return "\"" + s + "\""
}

// Sample generates an example JSON value for this field in the form of:
//
//	"field": "sample value
func (f Field) Sample() string {
	var value string
	switch f.TypeName {
	case "string":
		switch f.Name {
		case "email":
			value = Quote("somebody@example.com")
		case "phone":
			value = Quote("+40743123123")
		case "error":
			value = Quote("some error occured")
		case "name":
			value = Quote("My Name Is")
		case "token":
			var b [16]byte
			_, err := rand.Read(b[:])
			if err != nil {
				panic(err)
			}
			str := base64.StdEncoding.EncodeToString(b[:])
			value = Quote(str)
		case "password":
			value = Quote("hackmenow")
		case "device":
			value = Quote("Schedder Android App 6.6beta")
		default:
			value = Quote("this-was-a-random-string")
		}
	case "Time":
		value = Quote(time.Now().String())
	case "UUID":
		id, err := uuid.NewUUID()
		if err != nil {
			panic(err) // really bro
		}
		value = Quote(id.String())
	case "IP":
		value = Quote("127.0.0.1")
	case "bool":
		if mrand.Intn(2) == 1 {
			value = "true"
		} else {
			value = "false"
		}
	default:
		panic("unimplemented" + f.TypeName)
	}

	return Quote(f.Name) + ": " + value
}

// DartName returns the Dart-Styled name of the field
func (f Field) DartName() string {
	var b strings.Builder
	splits := strings.Split(f.Name, "_")
	for i, v := range splits {
		if i == 0 {
			b.WriteString(v)
		} else {
			titleCase := cases.Title(language.English, cases.NoLower).String(v)

			b.WriteString(titleCase)
		}
	}
	return b.String()
}

// DartType returns the type that should be used in Dart for this field.
func (f Field) DartType() string {
	switch f.TypeName {
	case "string":
		return "String"
	case "UUID":
		return "String"
	case "Time":
		return "DateTime"
	case "IP":
		return "String"
	case "bool":
		return "bool"
	default:
		panic("don't know how to dartify " + f.TypeName)
	}
}

// TypeScriptType returns the type that should be used in TypeScript for this
// field.
func (f Field) TypeScriptType() string {
	switch f.TypeName {
	case "string":
		return "string"
	case "UUID":
		return "string"
	case "Time":
		return "string"
	case "IP":
		return "string"
	case "bool":
		return "bool"
	default:
		panic("don't know how to typescriptify " + f.TypeName)
	}
}

// UnDartify returns a Dart snippet that does the conversion from the type to
// the JSON value
func (f Field) UnDartify() string {
	switch f.DartType() {
	case "String":
		return ""
	case "DateTime":
		return ".toIso8601String()"
	case "bool":
		return ""
	default:
		panic("don't know how to undartify " + f.TypeName)
	}
}

// Object represent a JSON object, with fields, arrays, and subobjects
type Object struct {
	Name   string
	Fields []Field

	Arrays  map[string]*Object
	Objects map[string]*Object
}

// Indent creates a string to be used for identation
func Indent(level int) string {
	return strings.Repeat("\t", level)
}

// Sample generates a sample JSON.
func (o *Object) Sample(level int) string {
	sb := strings.Builder{}
	sb.WriteString(Indent(level))
	sb.WriteString("{\n")
	for i, f := range o.Fields {
		sb.WriteString(Indent(level + 1))
		sb.WriteString(f.Sample())
		if i != (len(o.Fields) - 1) {
			sb.WriteRune(',')
		}
		if f.OmitEmpty {
			sb.WriteString(" // omit if empty")
		}
		sb.WriteRune('\n')
	}
	for k, a := range o.Arrays {
		sb.WriteString(Indent(level + 1))
		sb.WriteString(Quote(k))
		sb.WriteString(": ")
		sb.WriteString("[\n")

		s := a.Sample(level + 2)
		sb.WriteString(s)
		sb.WriteString("\n")

		sb.WriteString(Indent(level + 1))
		sb.WriteString("]\n")
	}
	sb.WriteString(Indent(level))
	sb.WriteString("}")
	return sb.String()
}

// ObjectStore stores all the objects, this type alias is used for convenience
type ObjectStore map[string]*Object

func fieldFromTag(tag string) (name string, omitempty bool) {
	tag = strings.TrimPrefix(tag, "`json:\"")
	tag = strings.TrimSuffix(tag, "\"`")
	splits := strings.Split(tag, ",")

	if len(splits) > 1 {
		return splits[0], splits[1] == "omitempty"
	}
	return splits[0], false
}

func simpleFunctionName(pc uintptr) string {
	f := runtime.FuncForPC(pc)
	_, name, _ := strings.Cut(f.Name(), "schedder-api.")
	name = strings.TrimPrefix(name, "(*API).")
	return name
}

func findJSONRequestType(middleware func(http.Handler) http.Handler) string {
	req := httptest.NewRequest("POST", "/", strings.NewReader("{}"))
	w := httptest.NewRecorder()

	var requestType reflect.Type

	handler := middleware(http.HandlerFunc(func(_ http.ResponseWriter, r *http.Request) {
		value := r.Context().Value(schedder.CtxJSON)
		requestType = reflect.TypeOf(value)
	}))

	handler.ServeHTTP(w, req)
	name := strings.TrimPrefix(requestType.String(), "*schedder.")
	return name
}

func (os ObjectStore) extractStruct(name string, st *ast.StructType) {
	arrays := make(map[string]*Object)
	fields := make([]Field, 0)
	for _, field := range st.Fields.List {
		if field.Names != nil && field.Tag != nil {
			tag, omitempty := fieldFromTag(field.Tag.Value)

			//tag := strings.Split(field.Tag.Value, "\"")[1]

			//fmt.Printf("\t\t%T %s %s\n", field.Type, field.Type, tag)
			//fmt.Printf("\t member %s of type %s json %s\n", field.Names[0], typeName, tag)

			switch t := field.Type.(type) {
			case *ast.Ident:
				fields = append(fields, Field{Name: tag, TypeName: t.Name, OmitEmpty: omitempty})
			case *ast.SelectorExpr:
				fields = append(fields, Field{Name: tag, TypeName: t.Sel.Name, OmitEmpty: omitempty})
			case *ast.ArrayType:
				elt := t.Elt.(*ast.Ident)
				arrays[tag] = os[elt.Name]
			default:
				//fmt.Printf("unhandled field %T %s", t, t)
				panic("unhandled type")
			}
		} else if field.Names == nil {
			if embedded, ok := field.Type.(*ast.Ident); ok {
				if embedded.Name == "Response" {
					//fmt.Printf("---> %T %s, %s\n", field.Type, field.Type, field.Names)
					fields = append(fields, Field{Name: "error", TypeName: "string", OmitEmpty: true})
				}
			}
		}
	}

	os[name].Fields = fields
	os[name].Arrays = arrays
	os[name].Name = name
}

// NewMiddleware processes the middleware into a Middleware struct
func NewMiddleware(middleware func(http.Handler) http.Handler) (mw Middleware) {
	pc := reflect.ValueOf(middleware).Pointer()
	fpn := simpleFunctionName(pc)
	if strings.HasPrefix(fpn, "WithJSON[...]") {
		reqType := findJSONRequestType(middleware)
		mw.TypeParam = reqType
	}

	mw.Name = fpn
	return
}

func main() {

	api := schedder.New(nil)

	b := bytes.Buffer{}

	endpoints := make([]Endpoint, 0)

	handleHandlers := func(_ string, pat string, handlers map[string]http.Handler, mws []Middleware) {
		for method, handle := range handlers {

			var endpoint http.Handler

			var ep Endpoint
			ep.Middlewares = make([]Middleware, len(mws))
			copy(ep.Middlewares, mws)

			chain, _ := handle.(*chi.ChainHandler)
			if chain != nil {
				for _, mw := range chain.Middlewares {
					newmw := NewMiddleware(mw)
					//fmt.Printf(ident+"mid: %s %s\n", newmw.name, newmw.typeParam)
					ep.Middlewares = append(ep.Middlewares, newmw)
				}
				endpoint = chain.Endpoint
			} else {
				endpoint = handle
			}

			fpn := runtime.FuncForPC(reflect.ValueOf(endpoint).Pointer()).Name()
			//fmt.Printf(ident+"fpn: %v\n", fpn)
			splits := strings.Split(fpn, ".")
			fpn = splits[len(splits)-1]
			fpn = strings.TrimSuffix(fpn, "-fm")
			//fmt.Printf(ident+"%s %s %s\n", method, fpn, pat)
			request := fmt.Sprintf("%s %s %s\n", method, fpn, pat)

			ep.Name = fpn
			ep.Path = pat
			ep.Method = method

			//fmt.Printf("=== %s %#v\n", ep.name, ep.middlewares)

			endpoints = append(endpoints, ep)
			b.WriteString(request)
		}
	}
	var f func(ident string, pattern string, r chi.Routes, mws []Middleware)
	f = func(ident string, pattern string, r chi.Routes, mws []Middleware) {
		middlewares := make([]Middleware, len(mws))
		copy(middlewares, mws)
		for _, mw := range r.Middlewares() {
			newmw := NewMiddleware(mw)
			middlewares = append(middlewares, newmw)
			//fmt.Printf(ident+"mid: %s %s\n", newmw.name, newmw.typeParam)
		}
		for _, route := range r.Routes() {
			pat := strings.TrimSuffix(route.Pattern, "/*")
			pat = pattern + pat
			if route.SubRoutes == nil {
				handleHandlers(ident, pat, route.Handlers, middlewares)
			} else {
				sub := route.SubRoutes
				f(ident+"\t", pat, sub, middlewares)
			}
		}
	}

	f("", "", api.GetMux(), make([]Middleware, 0))

	os.WriteFile("/tmp/routes.txt", b.Bytes(), 0777)

	fset := token.NewFileSet()
	packages, err := parser.ParseDir(fset, ".", nil, parser.Mode(0))
	if err != nil {
		panic(err)
	}

	pkg, ok := packages["schedder"]
	if !ok {
		panic("couldn't find schedder package in workdir")
	}

	//fmt.Printf("pkg: %#v\n", pkg)

	objects := make(ObjectStore)

	for _, file := range pkg.Files {
		for _, declaration := range file.Decls {
			decl, ok := declaration.(*ast.GenDecl)
			if ok {
				for _, spec := range decl.Specs {
					typespec, ok := spec.(*ast.TypeSpec)
					if ok {
						_, ok := typespec.Type.(*ast.StructType)
						if ok {
							objects[typespec.Name.Name] = new(Object)
						}
					}
				}
			}
		}
	}

	for _, file := range pkg.Files {
		for _, declaration := range file.Decls {
			decl, ok := declaration.(*ast.GenDecl)
			if ok {
				for _, spec := range decl.Specs {
					typespec, ok := spec.(*ast.TypeSpec)
					if ok {
						structtype, ok := typespec.Type.(*ast.StructType)
						if ok {
							objects.extractStruct(typespec.Name.Name, structtype)
						}
					}
				}
			}
		}
	}

	fmt.Println(strings.Repeat("=", 80))

	for i := range endpoints {
		ep := &endpoints[i]
		fmt.Println(ep.Name, ep.Method, ep.Path)

		for _, m := range ep.Middlewares {
			if m.Name == "WithJSON[...]" {
				ep.Input = objects[m.TypeParam]
			}
			fmt.Printf("\tmid: %v\n", m)
		}

		ep.Output = objects[ep.Name+"Response"]

		if ep.Input != nil {
			fmt.Printf("\trequest: %s\n", ep.Input.Name)
			fmt.Printf("\tsample request: \n%s\n", ep.Input.Sample(1))
		}

		if ep.Output != nil {
			fmt.Printf("\tresponse: %s\n", ep.Output.Name)
			fmt.Printf("\tsample response: \n%s\n", ep.Output.Sample(1))
		}
	}

	fmt.Println(strings.Repeat("=", 80))

	path := "/tmp"

	err = os.MkdirAll(path, os.ModeDir)
	if err != nil {
		panic(err)
	}

	generateHTML(objects, endpoints, path)
	generateDart(objects, endpoints, path)
	generateTypeScript(objects, endpoints, path)
}
